package main

import "fmt"

func main() {
	var x, y, z uint8

	x = 9
	y = 28
	z = x

	fmt.Println("Битовые операции")

	fmt.Printf("^x = ^(%.8b)\n", 255^x)
	fmt.Printf("^x = ^(%.8b)\n", 255)

	fmt.Printf("^x      = ^(%d)      = ^(%.8b)            = %.8b = %d\n", x, x, ^x, ^x)
	fmt.Printf("x << 2  = (%d << 2)  = (%.8b << 2)        = %.8b = %d\n", x, x, x<<2, x<<2)
	fmt.Printf("x >> 2  = (%d >> 2)  = (%.8b >> 2)        = %.8b = %d\n", x, x, x>>2, x>>2)
	fmt.Printf("x & y   = (%d & %d)  = (%.8b & %.8b)  = %.8b = %d\n", x, y, x, y, x&y, x&y)
	fmt.Printf("x | y   = (%d | %d)  = (%.8b | %.8b)  = %.8b = %d\n", x, y, x, y, x|y, x|y)
	fmt.Printf("x ^ y   = (%d ^ %d)  = (%.8b ^ %.8b)  = %.8b = %d\n", x, y, x, y, x^y, x^y)
	fmt.Printf("x &^ y  = (%d &^ %d) = (%.8b &^ %.8b) = %.8b = %d\n", x, y, x, y, x&^y, x&^y)
	fmt.Printf("x %% y   = (%d %% %d)  = (%.8b %% %.8b)  = %.8b = %d\n", x, y, x, y, x%y, x%y)

	fmt.Println("\nБитовые операции с присваиванием")

	x = z                                                                                  // 9
	x &= y                                                                                 // x = 9 & 28
	fmt.Printf("x &= y   = (%d &= %d)  = (%.8b &= %.8b)  = %.8b = %d\n", z, y, z, y, x, x) // z = 9
	x = z                                                                                  // 9
	x |= y                                                                                 // x = 9 | 28 Повертає 1, якщо хоча б один із відповідних розрядів обох чисел дорівнює 1, виходить 00011101 = 29
	fmt.Printf("x |= y   = (%d |= %d)  = (%.8b |= %.8b)  = %.8b = %d\n", z, y, z, y, x, x) // z = 9
	x = z                                                                                  // 9
	x ^= y                                                                                 // x = 9 ^ 28 копіює біт, якщо він встановлений в одному операнді, але не в обох, 00001001 = 00001001 ^ 00011100 = 00010101 = 21
	fmt.Printf("x ^= y   = (%d ^= %d)  = (%.8b ^= %.8b)  = %.8b = %d\n", z, y, z, y, x, x)
	x = z   // 9
	x &^= y // x = 9 &^ 28 кожен біт x дорівнює 0, якщо відповідний біт 28 дорівнює 1. Якщо біт y дорівнює 0, то береться значення відповідного біта з x.
	fmt.Printf("x &^= y  = (%d &^= %d) = (%.8b &^= %.8b) = %.8b = %d\n", z, y, z, y, x, x)
	x = z  //9
	x %= y // x = 9 % 28 остача від 28 буде 9
	fmt.Printf("x %%= y   = (%d %%= %d)  = (%.8b %%= %.8b)  = %.8b = %d\n", z, y, z, y, x, x)

	//Задание.
	//1. Пояснить результаты операций

	/*
		1. fmt.Printf("^x      = ^(%d)      = ^(%.8b)            = %.8b = %d\n", x, x, ^x, ^x)
		Двійковий оператор XOR копіює біт, якщо він встановлений в одному операнді, але не в обох.
		11111111
		00001001
		11110110 - Результат, в 10 - 246
		2. fmt.Printf("x << 2  = (%d << 2)  = (%.8b << 2)        = %.8b = %d\n", x, x, x<<2, x<<2)
		Зсуває бітове уявлення числа, представленого першим операндом, ліворуч на певну кількість розрядів(2), що задається другим операндом
		1001 << 2 = 100100 в 10 - 36
		3. fmt.Printf("x >> 2  = (%d >> 2)  = (%.8b >> 2)        = %.8b = %d\n", x, x, x>>2, x>>2)
		Зсуває бітове уявлення числа вправо певну кількість розрядів. 1001 >> 2 = 10 = 2
		4.fmt.Printf("x & y   = (%d & %d)  = (%.8b & %.8b)  = %.8b = %d\n", x, y, x, y, x&y, x&y)
		Порозрядна кон'юнкція (операція І чи порозрядне множення). Повертає 1, якщо обидва з відповідних розрядів обох чисел дорівнюють 1. Повертає 0, якщо розряд хоча б одного числа дорівнює 0
		00001001 & 00011100 - перемножаємо і отримуємо = 00001000 = 8
		5.fmt.Printf("x | y   = (%d | %d)  = (%.8b | %.8b)  = %.8b = %d\n", x, y, x, y, x|y, x|y)
		Порозрядна диз'юнкція (операція АБО або порозрядне складання). Повертає 1, якщо хоча б один із відповідних розрядів обох чисел дорівнює 1
		Складаємо розряди (00001001 | 00011100)  = 00011101 = 29
		6.fmt.Printf("x ^ y   = (%d ^ %d)  = (%.8b ^ %.8b)  = %.8b = %d\n", x, y, x, y, x^y, x^y)
		Порозрядне виключає АБО. Повертає 1, якщо тільки один із відповідних розрядів обох чисел дорівнює 1, якщо два розряди по 1 то нуль
		(00001001 ^ 00011100)  = 00010101 = 21
		7.fmt.Printf("x &^ y  = (%d &^ %d) = (%.8b &^ %.8b) = %.8b = %d\n", x, y, x, y, x&^y, x&^y)
		Скидання біта (І НЕ). У виразі z = x &^ y кожен біт z дорівнює 0, якщо відповідний біт y дорівнює 1. Якщо біт y дорівнює 0, то береться значення відповідного біта з x.
		(00001001 &^ 00011100) = 00000001 = 1
		8. fmt.Printf("x %% y   = (%d %% %d)  = (%.8b %% %.8b)  = %.8b = %d\n", x, y, x, y, x%y, x%y)
		Залишок від ділення 9 % 28 буде 9
	*/

	//fmt.Printf("x &= y   = (%d &= %d)  = (%.8b &= %.8b)  = %.8b = %d\n", z, y, z, y, x, x)
	//побітовий оператор присвоєння AND (x &= y так же само як і x = x & y)
	//00001001 = 00001001 & 00011100 = 00001000 = 8

	//

}
